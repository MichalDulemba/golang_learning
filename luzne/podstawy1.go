package main

import (
	"fmt"
	"time"
	"math/rand"
)

func main() {
	// mojaTablica := []int{3,4,5,2,4,5,2}
	// for i, v:=range mojaTablica{
	// fmt.Println(i, v)
	// }
	//
	// mniejszaTablica:=mojaTablica[3:5]
	// fmt.Println(mniejszaTablica)
	//
	// var licznik int = 0
	//
	//
	// var z float32
	//
	// AAA:
	// for {
	//     licznik++
	//     BBB:
	//     for z<1000{
	//         z++
	//         if z>100{
	//             fmt.Println("break to Z")
	//             break BBB
	//         }
	//     }
	//     if licznik>100{
	//     break AAA
	//     }
	//
	//
	// }
	// fmt.Println("after")

// 	newChannel := make(chan string)
// 	go sendMeSomething(newChannel)
//     for x := range newChannel {
// 		//     dane, ok := <- newChannel
// 		//     if ok==false{
// 		//         fmt.Println("error", ok)
// 		//     }
// 		fmt.Println("received", x)
// 	}

	newChannel2 := make(chan *string)
	go sendMeAPointer(newChannel2)

	for x := range newChannel2 {
	    start := time.Now()
		fmt.Println("received", *x)
		end := time.Since(start)
		fmt.Println("receiving pointer took ", end)
	}




	newChannel3 := make(chan string)
	go sendMeText(newChannel3)

	for x:= range newChannel3{
	    start := time.Now()
	    fmt.Println("received", x)
	    end := time.Since(start)
	    fmt.Println("receiving text took", end)
	}
    //myVal := 3000000
	//w:=createArray(myVal)
	sliceChannel := make(chan []int)
	go sendLargeArray(sliceChannel)
	start := time.Now()
	x := <- sliceChannel
	end := time.Since(start)
	fmt.Println(len(x), end)

	slicePointerChannel := make(chan *[]int)
	go sendLargeArrayPointer(slicePointerChannel)
	start1 := time.Now()
	y := <- slicePointerChannel
	end1 := time.Since(start1)
	fmt.Println(len(*y), end1)

	fmt.Println("finito main")

}

// func sendMeSomething(channelName chan string) {
// 	channelName <- "slowko"
// 	channelName <- "slowko2"
// 	channelName <- "slowko3"
// 	fmt.Println("sent")
// 	close(channelName)
// }

func sendMeAPointer(channelName chan *string) {
	var dlugiText string
	dlugiText = `Other idioms, such as time.Since(start), time.Until(deadline), and time.Now().Before(deadline), are similarly robust against wall clock resets.
                 The rest of this section gives the precise details of how operations use monotonic clocks, but understanding those details is not required to use this package.
                 The Time returned by time.Now contains a monotonic clock reading. If Time t has a monotonic clock reading, t.Add adds the same duration to both the wall clock and monotonic clock readings to compute the result. Because t.AddDate(y, m, d), t.Round(d), and t.Truncate(d) are wall time computations, they always strip any monotonic clock reading from their results. Because t.In, t.Local, and t.UTC are used for their effect on the interpretation of the wall time, they also strip any monotonic clock reading from their results. The canonical way to strip a monotonic clock reading is to use t = t.Round(0).
                 If Times t and u both contain monotonic clock readings, the operations t.After(u), t.Before(u), t.Equal(u), and t.Sub(u) are carried out using the monotonic clock readings alone, ignoring the wall clock readings. If either t or u contains no monotonic clock reading, these operations fall back to using the wall clock readings.
                 On some systems the monotonic clock will stop if the computer goes to sleep. On such a system, t.Sub(u) may not accurately reflect the actual time that passed between t and u.
                 Because the monotonic clock reading has no meaning outside the current process, the serialized forms generated by t.GobEncode, t.MarshalBinary, t.MarshalJSON, and t.MarshalText omit the monotonic clock reading, and t.Format provides no format for it. Similarly, the constructors time.Date, time.Parse, time.ParseInLocation, and time.Unix, as well as the unmarshalers t.GobDecode, t.UnmarshalBinary. t.UnmarshalJSON, and t.UnmarshalText always create times with no monotonic clock reading.
                 Note that the Go == operator compares not just the time instant but also the Location and the monotonic clock reading. See the documentation for the Time type for a discussion of equality testing for Time values.
                 Other idioms, such as time.Since(start), time.Until(deadline), and time.Now().Before(deadline), are similarly robust against wall clock resets.
                                  The rest of this section gives the precise details of how operations use monotonic clocks, but understanding those details is not required to use this package.
                                  The Time returned by time.Now contains a monotonic clock reading. If Time t has a monotonic clock reading, t.Add adds the same duration to both the wall clock and monotonic clock readings to compute the result. Because t.AddDate(y, m, d), t.Round(d), and t.Truncate(d) are wall time computations, they always strip any monotonic clock reading from their results. Because t.In, t.Local, and t.UTC are used for their effect on the interpretation of the wall time, they also strip any monotonic clock reading from their results. The canonical way to strip a monotonic clock reading is to use t = t.Round(0).
                                  If Times t and u both contain monotonic clock readings, the operations t.After(u), t.Before(u), t.Equal(u), and t.Sub(u) are carried out using the monotonic clock readings alone, ignoring the wall clock readings. If either t or u contains no monotonic clock reading, these operations fall back to using the wall clock readings.
                                  On some systems the monotonic clock will stop if the computer goes to sleep. On such a system, t.Sub(u) may not accurately reflect the actual time that passed between t and u.
                                  Because the monotonic clock reading has no meaning outside the current process, the serialized forms generated by t.GobEncode, t.MarshalBinary, t.MarshalJSON, and t.MarshalText omit the monotonic clock reading, and t.Format provides no format for it. Similarly, the constructors time.Date, time.Parse, time.ParseInLocation, and time.Unix, as well as the unmarshalers t.GobDecode, t.UnmarshalBinary. t.UnmarshalJSON, and t.UnmarshalText always create times with no monotonic clock reading.
                                  Note that the Go == operator compares not just the time instant but also the Location and the monotonic clock reading. See the documentation for the Time type for a discussion of equality testing for Time values.
                                  Other idioms, such as time.Since(start), time.Until(deadline), and time.Now().Before(deadline), are similarly robust against wall clock resets.
                                                   The rest of this section gives the precise details of how operations use monotonic clocks, but understanding those details is not required to use this package.
                                                   The Time returned by time.Now contains a monotonic clock reading. If Time t has a monotonic clock reading, t.Add adds the same duration to both the wall clock and monotonic clock readings to compute the result. Because t.AddDate(y, m, d), t.Round(d), and t.Truncate(d) are wall time computations, they always strip any monotonic clock reading from their results. Because t.In, t.Local, and t.UTC are used for their effect on the interpretation of the wall time, they also strip any monotonic clock reading from their results. The canonical way to strip a monotonic clock reading is to use t = t.Round(0).
                                                   If Times t and u both contain monotonic clock readings, the operations t.After(u), t.Before(u), t.Equal(u), and t.Sub(u) are carried out using the monotonic clock readings alone, ignoring the wall clock readings. If either t or u contains no monotonic clock reading, these operations fall back to using the wall clock readings.
                                                   On some systems the monotonic clock will stop if the computer goes to sleep. On such a system, t.Sub(u) may not accurately reflect the actual time that passed between t and u.
                                                   Because the monotonic clock reading has no meaning outside the current process, the serialized forms generated by t.GobEncode, t.MarshalBinary, t.MarshalJSON, and t.MarshalText omit the monotonic clock reading, and t.Format provides no format for it. Similarly, the constructors time.Date, time.Parse, time.ParseInLocation, and time.Unix, as well as the unmarshalers t.GobDecode, t.UnmarshalBinary. t.UnmarshalJSON, and t.UnmarshalText always create times with no monotonic clock reading.
                                                   Note that the Go == operator compares not just the time instant but also the Location and the monotonic clock reading. See the documentation for the Time type for a discussion of equality testing for Time values.`
	start := time.Now()
	channelName <- &dlugiText
	end := time.Since(start)
	t := time.Now()
    elapsed := t.Sub(start)
	print("sending pointer took ", end.Nanoseconds(), "\n\n\n\n", elapsed)
	close(channelName)
}

func sendMeText(channelName chan string){
	var dlugiText string
	dlugiText = `Other idioms, such as time.Since(start), time.Until(deadline), and time.Now().Before(deadline), are similarly robust against wall clock resets.
                 The rest of this section gives the precise details of how operations use monotonic clocks, but understanding those details is not required to use this package.
                 The Time returned by time.Now contains a monotonic clock reading. If Time t has a monotonic clock reading, t.Add adds the same duration to both the wall clock and monotonic clock readings to compute the result. Because t.AddDate(y, m, d), t.Round(d), and t.Truncate(d) are wall time computations, they always strip any monotonic clock reading from their results. Because t.In, t.Local, and t.UTC are used for their effect on the interpretation of the wall time, they also strip any monotonic clock reading from their results. The canonical way to strip a monotonic clock reading is to use t = t.Round(0).
                 If Times t and u both contain monotonic clock readings, the operations t.After(u), t.Before(u), t.Equal(u), and t.Sub(u) are carried out using the monotonic clock readings alone, ignoring the wall clock readings. If either t or u contains no monotonic clock reading, these operations fall back to using the wall clock readings.
                 On some systems the monotonic clock will stop if the computer goes to sleep. On such a system, t.Sub(u) may not accurately reflect the actual time that passed between t and u.
                 Because the monotonic clock reading has no meaning outside the current process, the serialized forms generated by t.GobEncode, t.MarshalBinary, t.MarshalJSON, and t.MarshalText omit the monotonic clock reading, and t.Format provides no format for it. Similarly, the constructors time.Date, time.Parse, time.ParseInLocation, and time.Unix, as well as the unmarshalers t.GobDecode, t.UnmarshalBinary. t.UnmarshalJSON, and t.UnmarshalText always create times with no monotonic clock reading.
                 Note that the Go == operator compares not just the time instant but also the Location and the monotonic clock reading. See the documentation for the Time type for a discussion of equality testing for Time values.
                 Other idioms, such as time.Since(start), time.Until(deadline), and time.Now().Before(deadline), are similarly robust against wall clock resets.
                                  The rest of this section gives the precise details of how operations use monotonic clocks, but understanding those details is not required to use this package.
                                  The Time returned by time.Now contains a monotonic clock reading. If Time t has a monotonic clock reading, t.Add adds the same duration to both the wall clock and monotonic clock readings to compute the result. Because t.AddDate(y, m, d), t.Round(d), and t.Truncate(d) are wall time computations, they always strip any monotonic clock reading from their results. Because t.In, t.Local, and t.UTC are used for their effect on the interpretation of the wall time, they also strip any monotonic clock reading from their results. The canonical way to strip a monotonic clock reading is to use t = t.Round(0).
                                  If Times t and u both contain monotonic clock readings, the operations t.After(u), t.Before(u), t.Equal(u), and t.Sub(u) are carried out using the monotonic clock readings alone, ignoring the wall clock readings. If either t or u contains no monotonic clock reading, these operations fall back to using the wall clock readings.
                                  On some systems the monotonic clock will stop if the computer goes to sleep. On such a system, t.Sub(u) may not accurately reflect the actual time that passed between t and u.
                                  Because the monotonic clock reading has no meaning outside the current process, the serialized forms generated by t.GobEncode, t.MarshalBinary, t.MarshalJSON, and t.MarshalText omit the monotonic clock reading, and t.Format provides no format for it. Similarly, the constructors time.Date, time.Parse, time.ParseInLocation, and time.Unix, as well as the unmarshalers t.GobDecode, t.UnmarshalBinary. t.UnmarshalJSON, and t.UnmarshalText always create times with no monotonic clock reading.
                                  Note that the Go == operator compares not just the time instant but also the Location and the monotonic clock reading. See the documentation for the Time type for a discussion of equality testing for Time values.
                                  Other idioms, such as time.Since(start), time.Until(deadline), and time.Now().Before(deadline), are similarly robust against wall clock resets.
                                                   The rest of this section gives the precise details of how operations use monotonic clocks, but understanding those details is not required to use this package.
                                                   The Time returned by time.Now contains a monotonic clock reading. If Time t has a monotonic clock reading, t.Add adds the same duration to both the wall clock and monotonic clock readings to compute the result. Because t.AddDate(y, m, d), t.Round(d), and t.Truncate(d) are wall time computations, they always strip any monotonic clock reading from their results. Because t.In, t.Local, and t.UTC are used for their effect on the interpretation of the wall time, they also strip any monotonic clock reading from their results. The canonical way to strip a monotonic clock reading is to use t = t.Round(0).
                                                   If Times t and u both contain monotonic clock readings, the operations t.After(u), t.Before(u), t.Equal(u), and t.Sub(u) are carried out using the monotonic clock readings alone, ignoring the wall clock readings. If either t or u contains no monotonic clock reading, these operations fall back to using the wall clock readings.
                                                   On some systems the monotonic clock will stop if the computer goes to sleep. On such a system, t.Sub(u) may not accurately reflect the actual time that passed between t and u.
                                                   Because the monotonic clock reading has no meaning outside the current process, the serialized forms generated by t.GobEncode, t.MarshalBinary, t.MarshalJSON, and t.MarshalText omit the monotonic clock reading, and t.Format provides no format for it. Similarly, the constructors time.Date, time.Parse, time.ParseInLocation, and time.Unix, as well as the unmarshalers t.GobDecode, t.UnmarshalBinary. t.UnmarshalJSON, and t.UnmarshalText always create times with no monotonic clock reading.
                                                   Note that the Go == operator compares not just the time instant but also the Location and the monotonic clock reading. See the documentation for the Time type for a discussion of equality testing for Time values.`
    start := time.Now()
    channelName <- dlugiText
    end := time.Since(start)
    t := time.Now()
    elapsed := t.Sub(start)
    print("sending text took ", end.Nanoseconds(), "\n\n\n\n", elapsed)
    close(channelName)
}

func createArray(N int) []int{
    a := make([]int, N)
    start := time.Now()
    for i:=0; i < N; i++{
        a[i] = rand.Intn(100)
    }
    end := time.Since(start)
    fmt.Println("array creation took", end)
    return a
}
func sendLargeArray(sendback chan []int){

    w := createArray(30000000)
    start := time.Now()
    sendback <- w
    end := time.Since(start)

    fmt.Println("array sent in", end)
}
func sendLargeArrayPointer(sendback chan *[]int){
    w:= createArray(30000000)
    start := time.Now()
    sendback <- &w
    end := time.Since(start)
    fmt.Println("array pointer send in ", end)
}